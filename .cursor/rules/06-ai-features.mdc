---
description: AI功能开发和使用规范
alwaysApply: false
---

# AI 功能开发规范

## AI 模型管理

### 支持的AI模型
项目支持多个主流 AI 模型，包括：

1. **DeepSeek** (推荐，高性价比)
   - DeepSeek Chat
   - DeepSeek Coder
   - API地址: `https://api.deepseek.com/v1/chat/completions`

2. **通义千问** (阿里云)
   - 通义千问 Turbo (免费额度)
   - 通义千问 Plus
   - 通义千问 Max
   - API地址: `https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation`

3. **其他模型**
   - ChatGPT (OpenAI)
   - Claude (Anthropic)
   - 文心一言 (百度)
   - 讯飞星火

### AI模型配置

#### 数据模型
参考 [aiassistant/model/AiModel.py](mdc:platform-fastapi-server/aiassistant/model/AiModel.py)

```python
class AiModel(SQLModel, table=True):
    """AI模型配置表"""
    __tablename__ = "ai_model"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    model_name: str = Field(max_length=100, index=True)  # 模型名称（如：DeepSeek-Chat）
    model_code: str = Field(max_length=50, unique=True)  # 模型代码（如：deepseek-chat）
    provider: str = Field(max_length=50)  # 提供商（如：DeepSeek、阿里云）
    api_url: str = Field(max_length=500)  # API地址
    api_key: Optional[str] = Field(default=None, max_length=500)  # API密钥（加密存储）
    is_enabled: bool = Field(default=True)  # 是否启用
    description: Optional[str] = Field(default=None, max_length=500)  # 模型描述
    create_time: datetime = Field(default_factory=datetime.now)
    modify_time: datetime = Field(default_factory=datetime.now)
```

#### 配置API接口
参考 [aiassistant/api/AiModelController.py](mdc:platform-fastapi-server/aiassistant/api/AiModelController.py)

```python
module_name = "AiModel"
module_route = APIRouter(prefix=f"/{module_name}", tags=["AI模型管理"])

# 标准CRUD接口
@module_route.post("/queryByPage")       # 分页查询
@module_route.get("/queryById")          # 根据ID查询
@module_route.get("/queryEnabled")       # 查询已启用的模型
@module_route.post("/insert")            # 新增模型
@module_route.put("/update")             # 更新模型
@module_route.delete("/delete")          # 删除模型
@module_route.post("/toggleStatus")      # 切换启用/禁用状态
@module_route.post("/testConnection")    # 测试模型连接

# 测试连接示例
@module_route.post("/testConnection")
async def testConnection(id: int = Query(...), session: Session = Depends(get_session)):
    """测试模型API连接"""
    model = session.get(AiModel, id)
    if not model:
        return respModel.error_resp(msg="AI模型不存在")
    
    # 发送测试请求到AI API
    async with httpx.AsyncClient(timeout=10.0) as client:
        response = await client.post(
            model.api_url,
            headers={"Authorization": f"Bearer {model.api_key}"},
            json={"model": model.model_code, "messages": [{"role": "user", "content": "测试"}]}
        )
        
        if response.status_code == 200:
            return respModel.ok_resp(msg="连接测试成功")
        else:
            return respModel.error_resp(msg=f"连接失败，状态码: {response.status_code}")
```

## 提示词模板管理

### 模板类型
项目支持三种模板类型，对应AI对话的角色：
- **system** - 系统提示词（定义AI角色和行为）
- **user** - 用户提示词（用户输入模板）
- **assistant** - 助手提示词（AI响应示例）

### 测试类型
- **API** - API测试用例生成
- **Web** - Web测试用例生成
- **App** - App测试用例生成
- **通用** - 通用测试场景

### 模板结构
参考 [aiassistant/model/PromptTemplate.py](mdc:platform-fastapi-server/aiassistant/model/PromptTemplate.py)

```python
class PromptTemplate(SQLModel, table=True):
    """提示词模板表"""
    __tablename__ = "prompt_template"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=100, index=True)  # 模板名称
    template_type: str = Field(max_length=20, index=True)  # 模板类型（system/user/assistant）
    test_type: str = Field(max_length=20, index=True)  # 测试类型（API/Web/App/通用）
    content: str = Field(sa_type=Text)  # 模板内容（支持变量如{test_type}、{case_count}）
    variables: Optional[str] = Field(default=None, max_length=500)  # 支持的变量列表（JSON格式）
    is_active: bool = Field(default=True)  # 是否激活
    created_by: Optional[int] = Field(default=None)  # 创建人ID
    create_time: datetime = Field(default_factory=datetime.now)
    modify_time: datetime = Field(default_factory=datetime.now)
    
    class Config:
        json_schema_extra = {
            "example": {
                "name": "API测试用例生成提示词",
                "template_type": "system",
                "test_type": "API",
                "content": "你是一位专业的测试工程师，擅长编写{test_type}测试用例。请根据用户需求生成{case_count}个测试用例，格式为JSON。",
                "variables": '["test_type", "case_count"]',
                "is_active": True
            }
        }
```

### 提示词编写规范

#### API测试用例生成提示词
```text
你是一个专业的API测试工程师，请根据以下需求生成API测试用例。

## 需求信息
{requirement}

## 输出格式要求
请生成 {count} 个测试用例，每个用例包含：
1. 用例名称
2. 测试目的
3. 优先级 (P0/P1/P2/P3)
4. 前置条件
5. 测试步骤
6. 预期结果
7. 测试数据

## 测试类型覆盖
- 正常场景测试
- 异常场景测试
- 边界值测试
- 安全性测试

## 输出格式
以JSON数组格式输出，每个测试用例为一个对象。

## 示例
[
  {
    "name": "用户登录成功测试",
    "purpose": "验证用户使用正确的用户名和密码能够成功登录",
    "priority": "P0",
    "precondition": "用户已注册且账号状态正常",
    "steps": ["打开登录页面", "输入用户名", "输入密码", "点击登录按钮"],
    "expected": "登录成功，跳转到首页，显示用户信息",
    "test_data": {
      "username": "testuser",
      "password": "123456"
    }
  }
]
```

#### Web测试用例生成提示词
```text
你是一个专业的Web测试工程师，请根据以下需求生成Web UI测试用例。

## 需求信息
{requirement}

## 输出要求
生成 {count} 个Web测试用例，覆盖：
- 功能测试
- UI/UX测试
- 兼容性测试
- 响应式测试
- 性能测试

## 测试要点
1. 页面元素定位
2. 用户交互流程
3. 数据验证
4. 错误提示
5. 边界条件

请以JSON格式输出测试用例。
```

#### App测试用例生成提示词
```text
你是一个专业的移动App测试工程师，请根据以下需求生成App测试用例。

## 需求信息
{requirement}

## 测试平台
- iOS 13+
- Android 8+

## 输出要求
生成 {count} 个App测试用例，覆盖：
- 功能测试
- UI测试
- 兼容性测试
- 性能测试
- 网络环境测试
- 权限测试

请以JSON格式输出测试用例。
```

## AI流式对话实现

### 流式对话架构
项目使用 SSE (Server-Sent Events) 实现实时流式对话，核心组件：
- **AiConversationController** - 对话控制器（SSE接口）
- **AiStreamService** - AI流式调用服务
- **ConversationService** - 对话上下文管理
- **PromptService** - 提示词构建服务
- **StreamTestCaseParser** - 流式测试用例解析器

### 流式对话接口
参考 [aiassistant/api/AiConversationController.py](mdc:platform-fastapi-server/aiassistant/api/AiConversationController.py)

```python
@router.post("/chat")
async def chat_stream(req: MessageStreamRequest, session: Session = Depends(get_session)):
    """流式对话接口 - 使用SSE推送实时生成的内容"""
    
    async def _event_generator() -> AsyncGenerator[str, None]:
        parser = StreamTestCaseParser()
        full_response = ""
        test_cases = []
        
        try:
            # 1. 保存用户消息
            user_message = AiMessage(
                conversation_id=req.conversation_id,
                role="user",
                content=req.user_message,
                message_type="text"
            )
            session.add(user_message)
            session.commit()
            
            # 2. 获取对话和模型配置
            conversation = session.get(AiConversation, req.conversation_id)
            model = session.get(AiModel, req.model_id)
            
            # 3. 构建上下文和提示词
            context = ConversationService.build_context(session, req.conversation_id)
            system_prompt = PromptService.build_system_message(req.test_type, req.case_count)
            messages = [system_prompt] + context + [{"role": "user", "content": req.user_message}]
            
            # 4. 流式调用AI模型
            async for chunk in AiStreamService.call_ai_stream(
                model.model_code, model.api_key, model.api_url,
                messages, temperature=0.7, max_tokens=req.max_tokens
            ):
                full_response += chunk
                
                # 推送文本片段
                yield f"data: {json.dumps({'type': 'text', 'content': chunk})}\n\n"
                
                # 实时解析测试用例
                test_case = parser.parse_chunk(chunk)
                if test_case:
                    test_cases.append(test_case)
                    yield f"data: {json.dumps({'type': 'testcase', 'data': test_case})}\n\n"
            
            # 5. 处理剩余内容
            final_case = parser.flush()
            if final_case:
                test_cases.append(final_case)
                yield f"data: {json.dumps({'type': 'testcase', 'data': final_case})}\n\n"
            
            # 6. 保存AI响应消息
            ai_message = AiMessage(
                conversation_id=req.conversation_id,
                role="assistant",
                content=full_response,
                message_type="testcase",
                test_cases_json=json.dumps(test_cases, ensure_ascii=False)
            )
            session.add(ai_message)
            
            # 7. 更新对话统计
            conversation.message_count += 2
            conversation.test_case_count += len(test_cases)
            conversation.update_time = datetime.now()
            session.commit()
            
            # 8. 推送完成消息
            yield f"data: {json.dumps({'type': 'done', 'message_id': ai_message.id, 'test_case_count': len(test_cases)})}\n\n"
            
        except Exception as e:
            logger.error(f"Stream error: {str(e)}")
            yield f"data: {json.dumps({'type': 'error', 'error': str(e)})}\n\n"
        finally:
            session.close()
    
    return EventSourceResponse(_event_generator(), media_type="text/event-stream")
```

### SSE消息格式
流式对话推送4种类型的消息：

```python
# 1. 文本片段
{"type": "text", "content": "这是一段文本"}

# 2. 测试用例（实时解析）
{"type": "testcase", "data": {"id": 1, "name": "登录测试", "steps": [...]}}

# 3. 完成消息
{"type": "done", "message_id": 123, "test_case_count": 5}

# 4. 错误消息
{"type": "error", "error": "错误描述"}
```

### 核心服务说明

#### 1. AiStreamService (core/AiStreamService.py)
```python
class AiStreamService:
    @staticmethod
    async def call_ai_stream(model_code, api_key, api_url, messages, temperature=0.7, max_tokens=4000):
        """流式调用AI模型"""
        async with httpx.AsyncClient(timeout=120.0) as client:
            async with client.stream(
                "POST", api_url,
                headers={"Authorization": f"Bearer {api_key}"},
                json={"model": model_code, "messages": messages, "stream": True, "temperature": temperature, "max_tokens": max_tokens}
            ) as response:
                async for line in response.aiter_lines():
                    if line.startswith("data: "):
                        # 解析并返回SSE数据
                        yield parsed_chunk
```

#### 2. ConversationService (core/ConversationService.py)
```python
class ConversationService:
    @staticmethod
    def build_context(session, conversation_id, max_messages=10):
        """构建对话上下文（最近N条消息）"""
        messages = session.exec(
            select(AiMessage)
            .where(AiMessage.conversation_id == conversation_id)
            .order_by(AiMessage.create_time.desc())
            .limit(max_messages)
        ).all()
        return [{"role": m.role, "content": m.content} for m in reversed(messages)]
```

#### 3. PromptService (core/PromptService.py)
```python
class PromptService:
    @staticmethod
    def build_system_message(test_type, case_count):
        """构建系统提示词"""
        return {
            "role": "system",
            "content": f"你是一位专业的{test_type}测试工程师，请根据用户需求生成{case_count}个测试用例..."
        }
```

#### 4. StreamTestCaseParser (core/StreamTestCaseParser.py)
```python
class StreamTestCaseParser:
    """流式测试用例解析器 - 实时解析JSON格式的测试用例"""
    
    def parse_chunk(self, chunk: str) -> dict:
        """解析文本片段，提取完整的测试用例"""
        # 实现实时JSON解析逻辑
        pass
```

## 前端对话界面集成

### SSE客户端实现
前端使用 EventSource 接收 SSE 流式消息：

```javascript
// 发起流式对话请求
const startConversation = async (conversationId, userMessage) => {
  const eventSource = new EventSource(
    `/api/AiConversation/chat?conversation_id=${conversationId}&user_message=${encodeURIComponent(userMessage)}`
  )
  
  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data)
    
    switch (data.type) {
      case 'text':
        // 追加文本片段到显示区域
        appendText(data.content)
        break
        
      case 'testcase':
        // 显示实时解析的测试用例
        addTestCase(data.data)
        break
        
      case 'done':
        // 对话完成
        console.log(`生成了 ${data.test_case_count} 个测试用例`)
        eventSource.close()
        break
        
      case 'error':
        // 错误处理
        ElMessage.error(data.error)
        eventSource.close()
        break
    }
  }
  
  eventSource.onerror = (error) => {
    console.error('SSE连接错误:', error)
    eventSource.close()
  }
}
```

### React对话组件
项目的AI对话界面使用React开发，位于 `src/agent-react/` 目录：

```jsx
// agent-react/components/ChatInterface.jsx
import { useState, useEffect } from 'react'
import { useEventSource } from '@/hooks/useEventSource'
import ReactMarkdown from 'react-markdown'
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'

export default function ChatInterface({ conversationId, modelId }) {
  const [messages, setMessages] = useState([])
  const [testCases, setTestCases] = useState([])
  
  const handleSend = (userMessage) => {
    // 发起SSE流式请求
    const eventSource = useEventSource({
      url: '/api/AiConversation/chat',
      params: { conversation_id: conversationId, user_message: userMessage }
    })
    
    eventSource.on('text', (chunk) => {
      // 实时显示文本
      updateLastMessage(chunk)
    })
    
    eventSource.on('testcase', (testCase) => {
      // 显示测试用例
      setTestCases(prev => [...prev, testCase])
    })
    
    eventSource.on('done', () => {
      // 完成
      eventSource.close()
    })
  }
  
  return (
    <div className="chat-container">
      {/* Markdown渲染、代码高亮等 */}
    </div>
  )
}
```

## 数据模型

### AI对话相关数据模型
项目使用以下数据模型管理AI对话：

#### 1. AiConversation - 对话会话
```python
class AiConversation(SQLModel, table=True):
    """AI对话会话表"""
    __tablename__ = "ai_conversation"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(index=True)  # 用户ID
    session_title: str = Field(max_length=200)  # 对话标题
    model_id: int  # AI模型ID
    test_type: str = Field(max_length=20)  # 测试类型（API/Web/App）
    project_id: Optional[int] = None  # 关联项目ID
    message_count: int = Field(default=0)  # 消息数量
    test_case_count: int = Field(default=0)  # 生成的测试用例数量
    status: str = Field(max_length=20, default="active")  # 状态（active/archived/deleted）
    create_time: datetime = Field(default_factory=datetime.now)
    update_time: datetime = Field(default_factory=datetime.now)
    last_message_time: Optional[datetime] = None  # 最后消息时间
```

#### 2. AiMessage - 对话消息
```python
class AiMessage(SQLModel, table=True):
    """AI对话消息表"""
    __tablename__ = "ai_message"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    conversation_id: int = Field(index=True)  # 对话ID
    role: str = Field(max_length=20)  # 角色（user/assistant/system）
    content: str = Field(sa_type=Text)  # 消息内容
    message_type: str = Field(max_length=20, default="text")  # 消息类型（text/testcase）
    test_cases_json: Optional[str] = Field(sa_type=Text, default=None)  # 测试用例JSON
    create_time: datetime = Field(default_factory=datetime.now)
```

## 最佳实践

### 1. 提示词优化
- **明确角色**: 在system消息中定义AI的角色和专长
- **结构化输出**: 要求AI输出JSON格式的结构化数据
- **提供示例**: 在提示词中给出示例格式
- **限制长度**: 设置合理的 max_tokens 避免超长响应
- **温度控制**: 测试用例生成建议使用 0.7 左右的温度

### 2. 流式对话优化
- **实时解析**: 使用 StreamTestCaseParser 实时解析测试用例
- **上下文管理**: 限制对话历史记录数量（推荐10条）
- **超时处理**: 设置合理的超时时间（120秒）
- **错误恢复**: 捕获异常并推送错误消息给前端
- **连接管理**: 确保在finally块中关闭session

### 3. 性能优化
- **异步调用**: 使用 async/await 处理AI调用
- **流式响应**: 使用SSE避免长时间等待
- **数据库优化**: 批量保存消息和测试用例
- **连接池**: 使用httpx的连接池复用连接

### 4. 成本控制
- **模型选择**: 优先使用高性价比模型（如DeepSeek）
- **Token控制**: 限制每次请求的 max_tokens
- **缓存策略**: 缓存常用的提示词模板
- **用量监控**: 记录API调用次数和Token消耗

### 5. 质量保证
- **人工审核**: 生成的测试用例需要人工审核
- **编辑功能**: 提供测试用例编辑界面
- **版本管理**: 保存测试用例的修改历史
- **反馈机制**: 收集用户反馈优化提示词

### 6. 安全规范
- **API密钥保护**: 加密存储AI模型的API密钥
- **权限控制**: 验证用户对对话的访问权限
- **内容过滤**: 过滤敏感信息避免泄露
- **速率限制**: 限制单个用户的API调用频率

## 开发指南

### 添加新的AI模型
1. 在数据库中插入模型配置（AiModel表）
2. 在 AiStreamService 中适配新模型的API格式
3. 测试连接和流式响应
4. 更新前端模型选择列表

### 自定义提示词模板
1. 在 prompt_template 表中创建新模板
2. 定义模板变量（JSON格式）
3. 在 PromptService 中实现变量替换逻辑
4. 在前端添加模板选择和预览功能

### 扩展消息类型
1. 在 AiMessage 的 message_type 字段添加新类型
2. 在 StreamTestCaseParser 中实现新类型的解析
3. 在前端添加新类型消息的渲染逻辑
4. 更新SSE消息格式文档

## 技术栈

### 后端技术
- **FastAPI** - Web框架
- **SQLModel** - ORM
- **sse-starlette** - SSE支持
- **httpx** - 异步HTTP客户端（支持流式）
- **python-docx, PyPDF2** - 文档解析

### 前端技术
- **React 18** - UI框架（对话界面）
- **EventSource** - SSE客户端
- **React Markdown** - Markdown渲染
- **React Syntax Highlighter** - 代码高亮
- **Radix UI** - React组件库

## 前端AI生成对话框

### 对话框结构
```vue
<template>
  <el-dialog v-model="dialogVisible" title="AI生成测试用例" width="800px">
    <el-form :model="form" label-width="100px">
      <!-- AI模型选择 -->
      <el-form-item label="AI模型">
        <el-select v-model="form.model_id" placeholder="选择AI模型">
          <el-option
            v-for="model in enabledModels"
            :key="model.id"
            :label="model.model_name"
            :value="model.id"
          />
        </el-select>
      </el-form-item>
      
      <!-- 测试类型 -->
      <el-form-item label="测试类型">
        <el-radio-group v-model="form.test_type">
          <el-radio label="API">API测试</el-radio>
          <el-radio label="Web">Web测试</el-radio>
          <el-radio label="App">App测试</el-radio>
        </el-radio-group>
      </el-form-item>
      
      <!-- 需求描述 -->
      <el-form-item label="需求描述">
        <el-input
          v-model="form.requirement"
          type="textarea"
          :rows="8"
          placeholder="请输入需求描述..."
        />
      </el-form-item>
      
      <!-- 生成数量 -->
      <el-form-item label="生成数量">
        <el-input-number
          v-model="form.count"
          :min="1"
          :max="20"
        />
      </el-form-item>
    </el-form>
    
    <template #footer>
      <el-button @click="dialogVisible = false">取消</el-button>
      <el-button type="primary" @click="handleGenerate" :loading="loading">
        生成
      </el-button>
    </template>
  </el-dialog>
</template>

<script setup>
import { ref, reactive } from 'vue'
import { generateTestCases } from '@/api/ai'
import { ElMessage } from 'element-plus'

const dialogVisible = ref(false)
const loading = ref(false)
const form = reactive({
  model_id: null,
  test_type: 'API',
  requirement: '',
  count: 10
})

const handleGenerate = async () => {
  loading.value = true
  try {
    const res = await generateTestCases(form)
    // 处理生成结果
    emit('generated', res.data.test_cases)
    dialogVisible.value = false
    ElMessage.success('生成成功')
  } catch (error) {
    ElMessage.error('生成失败')
  } finally {
    loading.value = false
  }
}
</script>
```

## 使用指南

详细使用指南请参考: [QUICK_START_AI_TESTCASE.md](mdc:QUICK_START_AI_TESTCASE.md)

### 快速开始
1. 配置AI模型 API Key
2. 选择或创建提示词模板
3. 输入需求描述
4. 生成测试用例
5. 审核并保存用例

### 提示词编写技巧
1. 明确任务目标
2. 提供充足上下文
3. 指定输出格式
4. 给出示例参考
5. 限制输出长度
6. 使用分步指导

### 常见问题
1. **生成质量不高**: 优化提示词，提供更详细的需求描述
2. **API调用失败**: 检查API Key和网络连接
3. **响应超时**: 减少生成数量或调整超时时间
4. **格式解析失败**: 优化提示词中的格式要求
